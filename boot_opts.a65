
	.(

; opt0	bits are:
;	bit 7: copy of EDITOR ROM patch bit
;	bit 6: 1=80 col, 0=40 col
;	bit 5: 1=c64 kbd, 0=pet-N kbd
;	bit 4: 1=8296 memory map, 0= normal
;	bit 3: 1=USB support enabled from keyboard select
;	
; opts1 bits are:
;	bit 7: KERNAL enhancements
;	bit 6: BASIC enhancements
;	bit 5: new EDITOR (sjg)
;	bit 4: enable 65816 monitor
;	bit 3: enable SD-Card support
;	bit 2: SD unit#
;	bit 1: enable serial IEC support
;	bit 0: IEC/IEEE prio
; opts2 bits are:
;	bit 7: enable RS232 port A support
;	bit 6: enable RS232 port B support
;	bit 5: enable USB support (mouse/kbd)
;

ONCHAR	=81
OFFCHAR	=87

; to detect a UART 16550 

UART_RXTX       =0               ; DLAB=0 
UART_IER        =1               ; DLAB=0 
UART_DLL        =0               ; divisor latch low, DLAB=1 
UART_DLH        =1               ; divisor latch high, DLAB=1 
UART_IIR        =2               ; Irq Ident. Reg., read only 
UART_FCR        =2               ; FIFO Ctrl Reg., write only 
UART_LCR        =3               ; Line Ctrl Reg 
UART_MCR        =4               ; Modem Ctrl Reg 
UART_LSR        =5               ; Line Status Reg 
UART_MSR        =6               ; Modem Status Reg 
UART_SCR        =7               ; 'scratchpad', i.e. unused 

&&do_options_init_xl .(
	; switches to .xs
	sep #%00010000
	.xs

	jsr detect_xs

	; switches to .xs
	rep #%00010000
	.xl
	rts
	.)

&&do_options_xl .(
	jsr clrscreen_xl

	jsr opttext_xl

	; switches to .xs
	sep #%00010000
	.xs

	jsr set_opts_xs

doloop	lda #0
	sta opt

chkloop	lda opt
	beq chkloop

	jsr do_opt_xs
	bcc doloop

	rep #%00010000
	.xl

	pha
	jsr clrscreen_xl
	pla
	rts
	.)

	.xs
	; ----------------------------
	; detect logic
detect_xs .(
	;-- detect UART 1 at $e818
	.(
UART	=$e818
        ldy UART+UART_MCR
        lda #$10
        sta UART+UART_MCR
        lda UART+UART_MSR
        and #$f0
        bne nodev
        lda #$1f
        sta UART+UART_MCR
        lda UART+UART_MSR
        and #$f0
        cmp #$f0
        beq dev
nodev	sty UART+UART_MCR	; restore potential PIA register
	lda #%01111111
	jsr clrmask2
dev	.)
	.(
UART	=$e828
        ldy UART+UART_MCR
        lda #$10
        sta UART+UART_MCR
        lda UART+UART_MSR
        and #$f0
        bne nodev
        lda #$1f
        sta UART+UART_MCR
        lda UART+UART_MSR
        and #$f0
        cmp #$f0
        beq dev
nodev	sty UART+UART_MCR	; restore potential PIA register
	lda #%10111111
	jsr clrmask2
dev	.)
	; --
	; detect 2nd VIA
	.(
VIA2	=$e850
	lda VIA2+VIA_PCR
	and #%00010001
	sta VIA2+VIA_PCR
	cmp VIA2+VIA_PCR
	bne nodev
	ora #%01100110
	sta VIA2+VIA_PCR
	cmp VIA2+VIA_PCR
	beq dev
nodev	lda #%11111100
	jsr clrmask
dev	.)
	rts

clrmask	ldx #0
	tay
sm1	and opts_mask,x
	sta opts_mask,x
	tya
	inx
	cpx #10
	bcc sm1
	rts
clrmask2
	ldx #0
	tay
sm2	and opts_mask2,x
	sta opts_mask2,x
	tya
	inx
	cpx #10
	bcc sm2
	rts
	.)

	; ----------------------------
	; screen routines
	.(

	.xl

; screen position starts line 7, position 11
; distance every 3 chars
start	=$8000+40*10+11
pos	=2

&opttext_xl .(
	ldx #0
outl	lda text,x
	beq endt
	and #$bf	; to PET Screencode
	sta $8000+2*40,x
	inx
	bne outl
endt	
	rts

text	.asc "           MICRO-/ULTI-PET              "
	.asc "              OPTIONS                   "
	.asc "                                        "
	.asc "CRSR TO SELECT, SPC TO CHANGE, X TO EXIT"
	.asc "                                        "
	.asc "           <---NORMAL---><---SHIFTED--->"
	.asc "           1  2  4  6  8  1  2  4  6  8 "
	.asc "                                        "
	.asc "KERNAL                                  "
	.asc "BASIC                                   "
	.asc "EDITOR                                  "
	.asc "MONITOR                                 "
        .asc "SD-CARD                                 "
        .asc "SD UNIT                                 "
	.asc "SER IEC                                 "
	.asc "IEC PRIO                                "
	.asc "RS232 A                                 "
	.asc "RS232 B                                 "
        .asc "USB HID                                 "
	.asc 0
	.)

	.xs

&set_opts_xs .(

	ldx #0
	stx x
	ldy #0
	sty y
rowloop	
	jsr getpos
	ldy y
	ldx x
	cpy #8
	bcs upper
	lda opts_mask,x
	and pow2,y
	bra rl1
upper	lda opts_mask2,x
	and pow2-8,y
rl1	beq nextopt

	cpy #5
	beq unit
	cpy #7
	beq prio
	bcs uppr

	lda opts_vals,x
	and pow2,y
	jsr showopt
	bra nextopt
uppr	
	lda opts_vals2,x
	and pow2-8,y
	jsr showopt
	bra nextopt
unit
	lda unit_vals,x
	jsr showunit
	bra nextopt

prio	lda opts_vals,x
	and pow2,y
	jsr showprio
nextopt	inc x
	ldx x
	cpx #10
	bcc rowloop
	ldx #0
	stx x
	inc y
	ldy y
	cpy #11
	bcc rowloop
	ldy #0
	sty y
	jmp act
	.)

&do_opt_xs .(
	pha
	jsr deact
	pla
	cmp #TC_CRGT
	beq right
	cmp #TC_CLFT
	beq left
	cmp #TC_CUP
	beq up
	cmp #TC_CDWN
	beq down2
	cmp #" "
	beq action2
	cmp #"x"
	beq out
endo	jsr act
	clc
out	rts

down2	jmp down
action2	jmp action

left 	ldx x
	beq endo
	ldy y
	cpy #8
	bcs nxleft2
nxleft	dex
	lda opts_mask,x
	and pow2,y
	bne goleft
	txa
	bne nxleft
	beq endo
goleft	stx x
	bne endo
nxleft2	dex
	lda opts_mask2,x
	and pow2-8,y
	bne goleft
	txa
	bne nxleft2
	beq endo

right 	ldx x
nxrght	cpx #9
	bcs endo
	inx
	ldy y
	cpy #8
	bcs nxrght2
	lda opts_mask,x
	and pow2,y
	beq nxrght
gorght	stx x
	bne endo
nxrght2	lda opts_mask2,x
	and pow2-8,y
	bne gorght
	beq nxrght

up	ldy y
	beq endo
nxup	dey
	ldx x
	cpy #8
	bcs nxup2
	lda opts_mask,x
	and pow2,y
	bne goup
nxup2a	tya
	bne nxup
	beq endo
nxup2	lda opts_mask2,x
	and pow2-8,y
	beq nxup2a
goup	sty y
	bne endo2

down	ldy y
nxdown	cpy #10
	bcs endo2
	ldx x
	iny
	cpy #8
	bcs nxd2
	lda opts_mask,x
	and pow2,y
	beq nxdown
godo	sty y
endo2	jmp endo
nxd2	lda opts_mask2,x
	and pow2-8,y
	bne godo
	beq nxdown

&getpos	; activate an option
	lda #0
	sta pos+1
	lda y
	asl
	asl	
	asl	; by 8
	sta pos
	asl pos
	rol pos+1
	asl pos
	rol pos+1 ; by 32
	clc
	adc pos
	sta pos
	lda #0
	adc pos+1
	sta pos+1
	lda x
	asl
	adc x
	adc pos
	sta pos
	lda #0
	adc pos+1
	sta pos+1
	lda #<start-1
	clc
	adc pos
	sta pos
	lda #>start-1
	adc pos+1
	sta pos+1
	rts

&act	jsr getpos
	ldy #2
al	lda (pos),y
	ora #128
	sta (pos),y
	dey
	bpl al
	rts

deact	jsr getpos
	ldy #2
dl	lda (pos),y
	and #127
	sta (pos),y
	dey
	bpl dl
	rts

action	ldx x
	ldy y
	cpy #5
	beq actunit
	cpy #7
	beq actprio
	bcs act2
	lda opts_vals,x
	eor pow2,y
	sta opts_vals,x
	and pow2,y
	bra act2b
act2	lda opts_vals2,x
	eor pow2-8,y
	sta opts_vals2,x
	and pow2-8,y
act2b	jsr showopt
	jmp act
&showopt
	beq notset
	lda #ONCHAR
	.byt $2c
notset	lda #OFFCHAR
	ldy #1
	sta (pos),y
	rts

actunit
	ldx x
	lda unit_vals,x
	cmp #11
	bne ainc
	lda #7
ainc	inc
	sta unit_vals,x
	jsr showunit
	jmp endo
&showunit
	ldy #0
	pha
	cmp #10
	bcs tenplus
	lda #" "
	sta (pos),y
	iny
	pla
	ora #$30
	sta (pos),y
	rts
tenplus	lda #"1"
	sta (pos),y
	iny
	pla
	sbc #10
	ora #$30
	sta (pos),y
	rts

actprio
	ldx x
	lda opts_vals,x
	eor pow2,y
	sta opts_vals,x
	and pow2,y
	jsr showprio
	jmp endo
&showprio
	bne prioser
	lda #"P"
	.byt $2c
prioser	lda #"S"
	and #$bf
	ldy #1
	sta (pos),y
	rts
	.)

	.xl

        ; ----------------------------
        ; In: AC has key in ASCII
        ;
        ; out:  c=0:    no option
        ;       c=1:    result is in AC:
	;
	; stores selected options in 
	; opt0, opt1, opt2, and optu
        ;
        .xl
&&conv_char2opt_xl .(
        ldx #opts-chars-1
l0      cmp chars,x
        beq found       ; implicit sec
        dex
        bpl l0
        clc
        rts
found   cpx #10
	bcc notusb
	txa
	sbc #5
	tax
notusb
	lda optkbd
        and #%00101000  ; filter usb and c64 kbd flags
        ora opts,x
	sta opt0

	; copy editor ROM bit for easier EDIT rom selection
	lda opts_vals,x
	and #%00100000
	asl
	asl
	ora opt0
	sta opt0

	lda opts_vals,x
	and opts_mask,x
	sta opt1

	lda opts_vals2,x
	and opts_mask2,x
	sta opt2

	lda unit_vals,x
	sta optu
        sec
        rts
	.)

chars   .byt "12468"
        ; shifted keys from pet / c64 kbd
        .byt "1"+128,"2"+128,"4"+128,"6"+128,"8"+128
        ; shifted keys from USB
        .byt "!^"$^^*"
        .byt "o"
opts
        .byt %00000001          ; patched basic1
        .byt %00000010          ; patched basic2
        .byt %00000011          ; patched 40 col
        .byt %01000011          ; patched 8296
        .byt %01000011          ; patched 80 col

        .byt %00000001          ; unpatched basic1
        .byt %00000010          ; unpatched basic2
        .byt %00000011          ; unpatched 40 col
        .byt %01010011          ; unpatched 8296
        .byt %01000011          ; unpatched 80 col

        .byt %00000100          ; option menu

	; temp
x	.byt 0
y	.byt 0
row	.word 0

pow2	.byt %10000000
	.byt %01000000
	.byt %00100000
	.byt %00010000
	.byt %00001000
	.byt %00000100
	.byt %00000010
	.byt %00000001

	; bits are:
	
&opts_mask
	.byt %10000000		; 1
	.byt %00000000		; 2
	.byt %11111111		; 4
	.byt %11111111		; 6
	.byt %11111111		; 8

	.byt %10000000		; 1
	.byt %00000000		; 2
	.byt %11111111		; 4
	.byt %11111111		; 6
	.byt %11111111		; 8

&opts_mask2
	.byt %00000000		; 1
	.byt %00000000		; 2
	.byt %11100000		; 4
	.byt %11100000		; 6
	.byt %11100000		; 8

	.byt %00000000		; 1
	.byt %00000000		; 2
	.byt %11100000		; 4
	.byt %11100000		; 6
	.byt %11100000		; 8

opts_vals
	.byt %10000000		; 1
	.byt %00000000		; 2
	.byt %11111100		; 4
	.byt %11111100		; 6
	.byt %11111100		; 8

	.byt %00000000		; 1
	.byt %00000000		; 2
	.byt %00000000		; 4
	.byt %00000000		; 6
	.byt %00000000		; 8

opts_vals2
	.byt %00000000		; 1
	.byt %00000000		; 2
	.byt %00100000		; 4
	.byt %00100000		; 6
	.byt %00100000		; 8

	.byt %00000000		; 1
	.byt %00000000		; 2
	.byt %00000000		; 4
	.byt %00000000		; 6
	.byt %00000000		; 8

unit_vals
	.byt 8			; 1
	.byt 8			; 2
	.byt 8			; 4
	.byt 8			; 6
	.byt 8			; 8

	.byt 8			; 1
	.byt 8			; 2
	.byt 8			; 4
	.byt 8			; 6
	.byt 8			; 8

	.)
	.)

